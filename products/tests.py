# nexusmart_backend/products/tests.py

from django.urls import reverse # Used to generate URLs from URL names
from django.contrib.auth import get_user_model # Get the custom User model
from rest_framework import status # Provides HTTP status codes (e.g., 200 OK)
from rest_framework.test import APITestCase # Base class for DRF API tests
from .models import Category, Product # Import models to create test data

# Get the User model defined in settings.AUTH_USER_MODEL
User = get_user_model()

class ProductAPITests(APITestCase):
    """
    Tests for the Product API endpoints (ViewSet).
    """

    @classmethod
    def setUpTestData(cls):
        """
        Set up data for the whole test class.
        Runs once before all test methods.
        """
        # Create a test user (non-admin)
        cls.user = User.objects.create_user(username='testuser', password='password123')

        # Create a test category
        cls.category = Category.objects.create(name='Test Category', slug='test-category')

        # Create some test products
        cls.product1 = Product.objects.create(
            category=cls.category, name='Available Product 1', slug='available-product-1',
            price=10.00, stock=5, available=True
        )
        cls.product2 = Product.objects.create(
            category=cls.category, name='Available Product 2', slug='available-product-2',
            price=20.00, stock=10, available=True
        )
        cls.product3 = Product.objects.create(
            category=cls.category, name='Unavailable Product', slug='unavailable-product',
            price=30.00, stock=0, available=False # This one is unavailable
        )

        # Define URLs using reverse lookups (less brittle than hardcoding)
        # These names ('product-list', 'product-detail') are generated by the DefaultRouter
        # based on the 'basename' or model name in the ViewSet registration.
        cls.list_url = reverse('product-list') # URL for /api/v1/products/
        cls.detail_url = reverse('product-detail', kwargs={'pk': cls.product1.pk}) # URL for /api/v1/products/{product1.pk}/
        cls.unavailable_detail_url = reverse('product-detail', kwargs={'pk': cls.product3.pk}) # URL for unavailable product

    def setUp(self):
        """
        Set up for each test method.
        Runs before every single test method.
        We re-authenticate the client here if needed for specific tests.
        """
        # APITestCase provides self.client, which acts like an API client
        pass # No specific per-test setup needed for these tests yet

    # --- List Endpoint Tests ---

    def test_list_products_anonymous(self):
        """
        Ensure anonymous users can list available products.
        """
        response = self.client.get(self.list_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # Check pagination structure
        self.assertIn('count', response.data)
        self.assertIn('results', response.data)
        # Check that only available products are listed (2 in our setup)
        self.assertEqual(response.data['count'], 2)
        self.assertEqual(len(response.data['results']), 2)
        # Check names to be sure
        product_names = {p['name'] for p in response.data['results']}
        self.assertIn(self.product1.name, product_names)
        self.assertIn(self.product2.name, product_names)
        self.assertNotIn(self.product3.name, product_names) # Unavailable product shouldn't be listed

    def test_list_products_authenticated(self):
        """
        Ensure authenticated (non-admin) users can also list available products.
        (Behavior should be same as anonymous due to DjangoModelPermissionsOrAnonReadOnly)
        """
        # Authenticate the request as our test user
        self.client.force_authenticate(user=self.user)
        response = self.client.get(self.list_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['count'], 2) # Should still only list available products
        self.assertEqual(len(response.data['results']), 2)

    # --- Detail Endpoint Tests ---

    def test_retrieve_available_product_detail(self):
        """
        Ensure anonymous users can retrieve an available product's detail.
        """
        response = self.client.get(self.detail_url) # URL for product1 (available)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], self.product1.name)
        self.assertEqual(response.data['id'], self.product1.pk)
        # Check for nested category data (at least the ID)
        self.assertIn('category', response.data)
        self.assertEqual(response.data['category']['id'], self.category.pk)

    def test_retrieve_unavailable_product_detail(self):
        """
        Ensure retrieving an unavailable product results in a 404 Not Found.
        (Because our ViewSet's queryset filters for available=True)
        """
        response = self.client.get(self.unavailable_detail_url) # URL for product3 (unavailable)

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

    # --- Write Operation Tests (Basic - Requires Authentication) ---
    # We'll add more tests later for creating, updating, deleting,
    # and checking permissions more thoroughly.

    # Example: Test creating a product requires authentication
    def test_create_product_requires_authentication(self):
        """
        Ensure anonymous users cannot create products (POST).
        """
        new_product_data = {
            'category_id': self.category.pk,
            'name': 'New Test Product',
            'price': '99.99',
            'stock': 50
        }
        # Make request without authenticating client
        response = self.client.post(self.list_url, new_product_data, format='json')
        print(response.status_code)

        # Expecting 403 Forbidden because write operations require permissions
        # which anonymous users don't have via DjangoModelPermissionsOrAnonReadOnly
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

